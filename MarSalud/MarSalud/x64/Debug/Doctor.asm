; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32824.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__2972590E_concurrencysal@h DB 01H
__196CC136_sal@h DB 01H
__C395F66A_vadefs@h DB 01H
__D5C25611_vcruntime@h DB 01H
__311F130C_xkeycheck@h DB 01H
__AEBEEEE9_yvals_core@h DB 01H
__05EEB633_limits@h DB 01H
__7CE37BCF_climits DB 01H
__1B0272D9_corecrt@h DB 01H
__D5F74309_vcruntime_new@h DB 01H
__ED298667_vcruntime_new_debug@h DB 01H
__935DC21B_crtdbg@h DB 01H
__B40C025A_crtdefs@h DB 01H
__97CA0262_use_ansi@h DB 01H
__4E4CEF82_yvals@h DB 01H
__BB16330F_corecrt_math@h DB 01H
__3BF2A406_math@h DB 01H
__45DED006_corecrt_malloc@h DB 01H
__13F5961F_stddef@h DB 01H
__FD6DBD68_corecrt_search@h DB 01H
__E2E33A61_corecrt_wstdlib@h DB 01H
__6E5ACABA_stdlib@h DB 01H
__F80C593D_cstdlib DB 01H
__6CC4302B_xtr1common DB 01H
__7178C802_intrin0@inl@h DB 01H
__AD21BB51_intrin0@h DB 01H
__7BD6CF81_cmath DB 01H
__44420885_corecrt_stdio_config@h DB 01H
__AB601D8D_corecrt_wstdio@h DB 01H
__C1EC35D3_stdio@h DB 01H
__FAE305CF_cstdio DB 01H
__61CC25A1_errno@h DB 01H
__4BC88476_vcruntime_string@h DB 01H
__E4C945B4_corecrt_memcpy_s@h DB 01H
__8EAFF484_corecrt_memory@h DB 01H
__6490AEC5_corecrt_wstring@h DB 01H
__E8295E1E_string@h DB 01H
__B49EF1DD_cstring DB 01H
__EF1F6BBA_corecrt_wconio@h DB 01H
__74484FB3_corecrt_wctype@h DB 01H
__3D1D430C_corecrt_wdirect@h DB 01H
__8ECB7138_corecrt_share@h DB 01H
__DB7FEBA6_corecrt_wio@h DB 01H
__9A9F0068_corecrt_wprocess@h DB 01H
__369A9BC3_corecrt_wtime@h DB 01H
__CE789B9D_types@h DB 01H
__9901C817_stat@h DB 01H
__3FCAD62E_wchar@h DB 01H
__6068D39C_cwchar DB 01H
__23A856AA_iosfwd DB 01H
__5DC78390_cstddef DB 01H
__33B42F3D_initializer_list DB 01H
__BB98980C_stdint@h DB 01H
__4552B840_cstdint DB 01H
__7FB6D5C7_type_traits DB 01H
__CF01DCB6_utility DB 01H
__12DC71E1___msvc_iter_core@hpp DB 01H
__D740E0F1_xutility DB 01H
__C6EC57B1_iterator DB 01H
__F7972D0B_share@h DB 01H
__3D410F40___msvc_system_error_abi@hpp DB 01H
__67C27134_cerrno DB 01H
__FA77ED4C_malloc@h DB 01H
__89766DA4_corecrt_terminate@h DB 01H
__27A4BD10_eh@h DB 01H
__E5C78335_vcruntime_exception@h DB 01H
__7C536CCC_exception DB 01H
__B9985323_float@h DB 01H
__89A7CE48_cfloat DB 01H
__98438E05_isa_availability@h DB 01H
__EF41832C_limits DB 01H
__0DB0C2E5_new DB 01H
__765FE01A_xatomic@h DB 01H
__A594BF75_xmemory DB 01H
__DFFCB714___msvc_sanitizer_annotate_container@hpp DB 01H
__D14739E9_xstring DB 01H
__F51D5691_stdexcept DB 01H
__ED2630B9_xcall_once@h DB 01H
__E6D9FA8D_xerrc@h DB 01H
__0A9237D2_time@h DB 01H
__BD655389_ctime DB 01H
__618403B0_xtimec@h DB 01H
__F68435D1_xthreads@h DB 01H
__8474DFEE_atomic DB 01H
__527B2299_system_error DB 01H
__0632977E_vcruntime_typeinfo@h DB 01H
__A79F13E8_typeinfo DB 01H
__53EF8FA2_memory DB 01H
__7FAAD8AD_xfacet DB 01H
__53FF2065___msvc_xlocinfo_types@hpp DB 01H
__1EC467ED_ctype@h DB 01H
__F528E268_cctype DB 01H
__791C33B7_locale@h DB 01H
__6BA085EC_clocale DB 01H
__B816F020_xlocinfo DB 01H
__0E794DD8_xlocale DB 01H
__81F38733_xiosbase DB 01H
__F7BDEE2D_streambuf DB 01H
__90FE2BCF_xlocnum DB 01H
__F57DF8F3_ios DB 01H
__1D69971C_ostream DB 01H
__7EB9A226_istream DB 01H
__B5399AEE_iostream DB 01H
__1F2E278C_TiposForward@h DB 01H
__96A9FD24_Persona@h DB 01H
__229D2084_Modelo@h DB 01H
__7B1C2AE8_Doctor@h DB 01H
__3E732C05_Doctor@cpp DB 01H
msvcjmc	ENDS
PUBLIC	?__empty_global_delete@@YAXPEAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPEAX_K@Z		; __empty_global_delete
PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	printf
PUBLIC	?name@type_info@@QEBAPEBDXZ			; type_info::name
PUBLIC	?DoctorDefaultConstructor@@YAPEAUCDoctor@@XZ	; DoctorDefaultConstructor
PUBLIC	?DoctorConstructor@@YAPEAUCDoctor@@HPEAD000@Z	; DoctorConstructor
PUBLIC	?DoctorConstructorCopia@@YAPEAUCDoctor@@PEAUCPersona@@@Z ; DoctorConstructorCopia
PUBLIC	?DoctorDestructor@@YAXPEAUCDoctor@@@Z		; DoctorDestructor
PUBLIC	?_new@@YAPEAXPEAUCDoctor@@@Z			; _new
PUBLIC	?_delete@@YAXPEAUCDoctor@@@Z			; _delete
PUBLIC	?DoctorImprimirFicha@@YAXPEAUCDoctor@@H@Z	; DoctorImprimirFicha
PUBLIC	__JustMyCode_Default
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_R0?AUCPersona@@@8				; CPersona `RTTI Type Descriptor'
PUBLIC	??_R0?AUCDoctor@@@8				; CDoctor `RTTI Type Descriptor'
PUBLIC	??_C@_01EEMJAFIK@?6@				; `string'
PUBLIC	??_C@_0CH@NHOFDPHD@FICHA?5DE?5DOCTOR?3?5DATOS?5PROFESIO@ ; `string'
PUBLIC	??_C@_0CH@GPCMCKNF@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ ; `string'
PUBLIC	??_C@_0CC@EEDKFKPA@Direccion?5de?5puntero?5base?3?$CF016z@ ; `string'
PUBLIC	??_C@_0BO@JHLKPGDG@Numero?5de?5colegiado?4?4?4?4?4?4?3?$CFd?6@ ; `string'
PUBLIC	??_C@_0BO@OPKJLGFF@Universidad?4?4?4?4?4?4?4?4?4?4?4?4?4?4?3?$CFs?6@ ; `string'
PUBLIC	??_C@_0BO@FOLDGNFO@Especialidad?4?4?4?4?4?4?4?4?4?4?4?4?4?3?$CFs?6@ ; `string'
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vfprintf:PROC
EXTRN	memcpy:PROC
EXTRN	memset:PROC
EXTRN	strcpy:PROC
EXTRN	__std_type_info_name:PROC
EXTRN	?PersonaDefaultConstructor@@YAPEAUCPersona@@XZ:PROC ; PersonaDefaultConstructor
EXTRN	?_new@@YAPEAXPEAUCPersona@@@Z:PROC		; _new
EXTRN	?_delete@@YAXPEAUCPersona@@@Z:PROC		; _delete
EXTRN	?BuscarModelo@@YAPEAUCModelo@@PEAU1@PEAD@Z:PROC	; BuscarModelo
EXTRN	?InsertarModelo@@YA_NPEAUCModelo@@0@Z:PROC	; InsertarModelo
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	??_7type_info@@6B@:BYTE				; type_info::`vftable'
EXTRN	?__type_info_root_node@@3U__type_info_node@@A:BYTE ; __type_info_root_node
EXTRN	?_pListaModelos@@3PEAXEA:QWORD			; _pListaModelos
EXTRN	__security_cookie:QWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__empty_global_delete@@YAXPEAX@Z DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$?__empty_global_delete@@YAXPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__empty_global_delete@@YAXPEAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$?__empty_global_delete@@YAXPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$__local_stdio_printf_options DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$__local_stdio_printf_options
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+103
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN3
	DD	imagerel $LN3+191
	DD	imagerel $unwind$printf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?name@type_info@@QEBAPEBDXZ DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$?name@type_info@@QEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?DoctorDefaultConstructor@@YAPEAUCDoctor@@XZ DD imagerel $LN4
	DD	imagerel $LN4+359
	DD	imagerel $unwind$?DoctorDefaultConstructor@@YAPEAUCDoctor@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?DoctorConstructor@@YAPEAUCDoctor@@HPEAD000@Z DD imagerel $LN4
	DD	imagerel $LN4+193
	DD	imagerel $unwind$?DoctorConstructor@@YAPEAUCDoctor@@HPEAD000@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?DoctorConstructorCopia@@YAPEAUCDoctor@@PEAUCPersona@@@Z DD imagerel $LN4
	DD	imagerel $LN4+114
	DD	imagerel $unwind$?DoctorConstructorCopia@@YAPEAUCDoctor@@PEAUCPersona@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?DoctorDestructor@@YAXPEAUCDoctor@@@Z DD imagerel $LN5
	DD	imagerel $LN5+104
	DD	imagerel $unwind$?DoctorDestructor@@YAXPEAUCDoctor@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_new@@YAPEAXPEAUCDoctor@@@Z DD imagerel $LN6
	DD	imagerel $LN6+493
	DD	imagerel $unwind$?_new@@YAPEAXPEAUCDoctor@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_delete@@YAXPEAUCDoctor@@@Z DD imagerel $LN14
	DD	imagerel $LN14+520
	DD	imagerel $unwind$?_delete@@YAXPEAUCDoctor@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?DoctorImprimirFicha@@YAXPEAUCDoctor@@H@Z DD imagerel $LN7
	DD	imagerel $LN7+261
	DD	imagerel $unwind$?DoctorImprimirFicha@@YAXPEAUCDoctor@@H@Z
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0BO@FOLDGNFO@Especialidad?4?4?4?4?4?4?4?4?4?4?4?4?4?3?$CFs?6@
CONST	SEGMENT
??_C@_0BO@FOLDGNFO@Especialidad?4?4?4?4?4?4?4?4?4?4?4?4?4?3?$CFs?6@ DB 'E'
	DB	'specialidad.............:%s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@OPKJLGFF@Universidad?4?4?4?4?4?4?4?4?4?4?4?4?4?4?3?$CFs?6@
CONST	SEGMENT
??_C@_0BO@OPKJLGFF@Universidad?4?4?4?4?4?4?4?4?4?4?4?4?4?4?3?$CFs?6@ DB 'U'
	DB	'niversidad..............:%s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@JHLKPGDG@Numero?5de?5colegiado?4?4?4?4?4?4?3?$CFd?6@
CONST	SEGMENT
??_C@_0BO@JHLKPGDG@Numero?5de?5colegiado?4?4?4?4?4?4?3?$CFd?6@ DB 'Numero'
	DB	' de colegiado......:%d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@EEDKFKPA@Direccion?5de?5puntero?5base?3?$CF016z@
CONST	SEGMENT
??_C@_0CC@EEDKFKPA@Direccion?5de?5puntero?5base?3?$CF016z@ DB 'Direccion '
	DB	'de puntero base:%016zx', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@GPCMCKNF@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@
CONST	SEGMENT
??_C@_0CH@GPCMCKNF@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ DB '-'
	DB	'------------------------------------', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@NHOFDPHD@FICHA?5DE?5DOCTOR?3?5DATOS?5PROFESIO@
CONST	SEGMENT
??_C@_0CH@NHOFDPHD@FICHA?5DE?5DOCTOR?3?5DATOS?5PROFESIO@ DB 'FICHA DE DOC'
	DB	'TOR: DATOS PROFESIONALES:', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_R0?AUCDoctor@@@8
data$r	SEGMENT
??_R0?AUCDoctor@@@8 DQ FLAT:??_7type_info@@6B@		; CDoctor `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AUCDoctor@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AUCPersona@@@8
data$r	SEGMENT
??_R0?AUCPersona@@@8 DQ FLAT:??_7type_info@@6B@		; CPersona `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AUCPersona@@', 00H
data$r	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?DoctorImprimirFicha@@YAXPEAUCDoctor@@H@Z DD 025051701H
	DD	01122317H
	DD	0700b0021H
	DD	0500aH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	036H
	DW	01efH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_delete@@YAXPEAUCDoctor@@@Z DD 025053d19H
	DD	010e2313H
	DD	070070037H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	01a8H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
?_delete@@YAXPEAUCDoctor@@@Z$rtcName$0 DB 073H		; _delete
	DB	07aH
	DB	054H
	DB	079H
	DB	070H
	DB	065H
	DB	049H
	DB	044H
	DB	00H
	ORG $+7
?_delete@@YAXPEAUCDoctor@@@Z$rtcVarDesc DD 030H		; _delete
	DD	064H
	DQ	FLAT:?_delete@@YAXPEAUCDoctor@@@Z$rtcName$0
	ORG $+48
?_delete@@YAXPEAUCDoctor@@@Z$rtcFrameData DD 01H	; _delete
	DD	00H
	DQ	FLAT:?_delete@@YAXPEAUCDoctor@@@Z$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	036H
	DW	01d4H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_new@@YAPEAXPEAUCDoctor@@@Z DD 025053d19H
	DD	010e2313H
	DD	07007003bH
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	01c8H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
?_new@@YAPEAXPEAUCDoctor@@@Z$rtcName$0 DB 073H		; _new
	DB	07aH
	DB	054H
	DB	079H
	DB	070H
	DB	065H
	DB	049H
	DB	044H
	DB	00H
	ORG $+7
?_new@@YAPEAXPEAUCDoctor@@@Z$rtcVarDesc DD 070H		; _new
	DD	064H
	DQ	FLAT:?_new@@YAPEAXPEAUCDoctor@@@Z$rtcName$0
	ORG $+48
?_new@@YAPEAXPEAUCDoctor@@@Z$rtcFrameData DD 01H	; _new
	DD	00H
	DQ	FLAT:?_new@@YAPEAXPEAUCDoctor@@@Z$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?DoctorDestructor@@YAXPEAUCDoctor@@@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?DoctorConstructorCopia@@YAPEAUCDoctor@@PEAUCPersona@@@Z DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?DoctorConstructor@@YAPEAUCDoctor@@HPEAD000@Z DD 025052101H
	DD	011c2321H
	DD	070150021H
	DD	05014H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	02aH
	DW	014eH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?DoctorDefaultConstructor@@YAPEAUCDoctor@@XZ DD 025053119H
	DD	010a230fH
	DD	07003003fH
	DD	05002H
	DD	imagerel __GSHandlerCheck
	DD	01e8H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
?DoctorDefaultConstructor@@YAPEAUCDoctor@@XZ$rtcName$0 DB 073H ; DoctorDefaultConstructor
	DB	07aH
	DB	054H
	DB	079H
	DB	070H
	DB	065H
	DB	049H
	DB	044H
	DB	00H
	ORG $+7
?DoctorDefaultConstructor@@YAPEAUCDoctor@@XZ$rtcVarDesc DD 0b0H ; DoctorDefaultConstructor
	DD	064H
	DQ	FLAT:?DoctorDefaultConstructor@@YAPEAUCDoctor@@XZ$rtcName$0
	ORG $+48
?DoctorDefaultConstructor@@YAPEAUCDoctor@@XZ$rtcFrameData DD 01H ; DoctorDefaultConstructor
	DD	00H
	DQ	FLAT:?DoctorDefaultConstructor@@YAPEAUCDoctor@@XZ$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?name@type_info@@QEBAPEBDXZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	045H
	DB	0a6H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 025054c19H
	DD	011d2322H
	DD	070160029H
	DD	05015H
	DD	imagerel __GSHandlerCheck
	DD	0138H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
printf$rtcName$0 DB 05fH
	DB	041H
	DB	072H
	DB	067H
	DB	04cH
	DB	069H
	DB	073H
	DB	074H
	DB	00H
	ORG $+7
printf$rtcVarDesc DD 048H
	DD	08H
	DQ	FLAT:printf$rtcName$0
	ORG $+48
printf$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:printf$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 035052201H
	DD	011d3322H
	DD	07016001fH
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$__local_stdio_printf_options DD 025050f01H
	DD	010a230fH
	DD	07003001dH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__empty_global_delete@@YAXPEAX_K@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__empty_global_delete@@YAXPEAX@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Develop\Marcombo\MarSalud\MarSalud\Doctor.cpp
;	COMDAT ?DoctorImprimirFicha@@YAXPEAUCDoctor@@H@Z
_TEXT	SEGMENT
pPersona$ = 8
tv65 = 212
pDoctor$ = 256
nTipoFicha$ = 264
?DoctorImprimirFicha@@YAXPEAUCDoctor@@H@Z PROC		; DoctorImprimirFicha, COMDAT

; 232  : {

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__3E732C05_Doctor@cpp
	call	__CheckForDebuggerJustMyCode

; 233  :     CPersonaPtr pPersona = pDoctor->m_pPersona;

	mov	rax, QWORD PTR pDoctor$[rbp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR pPersona$[rbp], rax

; 234  : 
; 235  :     switch (nTipoFicha)

	mov	eax, DWORD PTR nTipoFicha$[rbp]
	mov	DWORD PTR tv65[rbp], eax
	cmp	DWORD PTR tv65[rbp], 0
	je	SHORT $LN4@DoctorImpr
	cmp	DWORD PTR tv65[rbp], 1
	je	$LN5@DoctorImpr
	jmp	$LN2@DoctorImpr
$LN4@DoctorImpr:

; 236  :     {
; 237  :     case 0:
; 238  :         printf("\n");

	lea	rcx, OFFSET FLAT:??_C@_01EEMJAFIK@?6@
	call	printf

; 239  :         printf("FICHA DE DOCTOR: DATOS PROFESIONALES:\n");

	lea	rcx, OFFSET FLAT:??_C@_0CH@NHOFDPHD@FICHA?5DE?5DOCTOR?3?5DATOS?5PROFESIO@
	call	printf

; 240  :         printf("-------------------------------------\n");

	lea	rcx, OFFSET FLAT:??_C@_0CH@GPCMCKNF@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@
	call	printf

; 241  :         printf("Direccion de puntero base:%016zx\n", (unsigned __int64)pDoctor->m_this); //64 bits

	mov	rax, QWORD PTR pDoctor$[rbp]
	mov	rdx, QWORD PTR [rax]
	lea	rcx, OFFSET FLAT:??_C@_0CC@EEDKFKPA@Direccion?5de?5puntero?5base?3?$CF016z@
	call	printf

; 242  :         printf("Numero de colegiado......:%d\n", pDoctor->m_nNumColegiado);

	mov	rax, QWORD PTR pDoctor$[rbp]
	mov	edx, DWORD PTR [rax+24]
	lea	rcx, OFFSET FLAT:??_C@_0BO@JHLKPGDG@Numero?5de?5colegiado?4?4?4?4?4?4?3?$CFd?6@
	call	printf

; 243  :         printf("Universidad..............:%s\n", pDoctor->m_szUniversidad);

	mov	rax, QWORD PTR pDoctor$[rbp]
	add	rax, 28
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:??_C@_0BO@OPKJLGFF@Universidad?4?4?4?4?4?4?4?4?4?4?4?4?4?4?3?$CFs?6@
	call	printf

; 244  :         printf("Especialidad.............:%s\n", pDoctor->m_szEspecialidad);

	mov	rax, QWORD PTR pDoctor$[rbp]
	add	rax, 128				; 00000080H
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:??_C@_0BO@FOLDGNFO@Especialidad?4?4?4?4?4?4?4?4?4?4?4?4?4?3?$CFs?6@
	call	printf
$LN5@DoctorImpr:

; 245  :         //El break se omite intencionadamente
; 246  :         //para que continúe imprimiendo los datos personales:
; 247  :     case 1:
; 248  :         //Llamar a la versión de la cápsula heredada CPersona:
; 249  :         (*pDoctor->m_pPersona->m_lpfnImprimirFicha)(pDoctor->m_pPersona);   

	mov	rax, QWORD PTR pDoctor$[rbp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR pDoctor$[rbp]
	mov	rcx, QWORD PTR [rcx+8]
	call	QWORD PTR [rax+984]
$LN2@DoctorImpr:

; 250  :         break;
; 251  :     }
; 252  : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
?DoctorImprimirFicha@@YAXPEAUCDoctor@@H@Z ENDP		; DoctorImprimirFicha
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Develop\Marcombo\MarSalud\MarSalud\Doctor.cpp
;	COMDAT ?_delete@@YAXPEAUCDoctor@@@Z
_TEXT	SEGMENT
szTypeID$ = 16
pFoundModelo$ = 152
pPreviousModelo$ = 184
__$ArrayPad$ = 392
pObjeto$ = 432
?_delete@@YAXPEAUCDoctor@@@Z PROC			; _delete, COMDAT

; 163  : {

$LN14:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 440				; 000001b8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+472]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__3E732C05_Doctor@cpp
	call	__CheckForDebuggerJustMyCode

; 164  :     char szTypeID[100];
; 165  :     CModeloPtr pFoundModelo = NULL;

	mov	QWORD PTR pFoundModelo$[rbp], 0

; 166  :     CModeloPtr pPreviousModelo = NULL;

	mov	QWORD PTR pPreviousModelo$[rbp], 0

; 167  : 
; 168  :     // Obtener el tipo del objeto:
; 169  :     memset(szTypeID, 0, sizeof(szTypeID));

	mov	r8d, 100				; 00000064H
	xor	edx, edx
	lea	rcx, QWORD PTR szTypeID$[rbp]
	call	memset

; 170  :     strcpy(szTypeID, typeid(*pObjeto).name());

	lea	rcx, OFFSET FLAT:??_R0?AUCDoctor@@@8
	call	?name@type_info@@QEBAPEBDXZ		; type_info::name
	mov	rdx, rax
	lea	rcx, QWORD PTR szTypeID$[rbp]
	call	strcpy

; 171  : 
; 172  :     if (_pListaModelos)

	cmp	QWORD PTR ?_pListaModelos@@3PEAXEA, 0	; _pListaModelos
	je	$LN2@delete

; 173  :     {
; 174  :         pFoundModelo = BuscarModelo((CModeloPtr)_pListaModelos, szTypeID);

	lea	rdx, QWORD PTR szTypeID$[rbp]
	mov	rcx, QWORD PTR ?_pListaModelos@@3PEAXEA	; _pListaModelos
	call	?BuscarModelo@@YAPEAUCModelo@@PEAU1@PEAD@Z ; BuscarModelo
	mov	QWORD PTR pFoundModelo$[rbp], rax

; 175  :         if (pFoundModelo)

	cmp	QWORD PTR pFoundModelo$[rbp], 0
	je	$LN3@delete

; 176  :         {
; 177  :             if (pFoundModelo == pObjeto->m_pModelo)

	mov	rax, QWORD PTR pObjeto$[rbp]
	mov	rax, QWORD PTR [rax+16]
	cmp	QWORD PTR pFoundModelo$[rbp], rax
	jne	$LN4@delete

; 178  :             {
; 179  :                 if (pObjeto->m_pModelo)

	mov	rax, QWORD PTR pObjeto$[rbp]
	cmp	QWORD PTR [rax+16], 0
	je	$LN5@delete

; 180  :                 {
; 181  :                     if (pFoundModelo->m_nContador > 0)

	mov	rax, QWORD PTR pFoundModelo$[rbp]
	cmp	DWORD PTR [rax+100], 0
	jle	SHORT $LN6@delete

; 182  :                     {
; 183  :                         pFoundModelo->m_nContador--;

	mov	rax, QWORD PTR pFoundModelo$[rbp]
	mov	eax, DWORD PTR [rax+100]
	dec	eax
	mov	rcx, QWORD PTR pFoundModelo$[rbp]
	mov	DWORD PTR [rcx+100], eax
$LN6@delete:

; 184  :                     }
; 185  :                     if (pFoundModelo->m_nContador == 0)

	mov	rax, QWORD PTR pFoundModelo$[rbp]
	cmp	DWORD PTR [rax+100], 0
	jne	SHORT $LN7@delete

; 186  :                     {
; 187  :                         //pObjeto->m_pModelo = NULL; //Borrado en la instancia
; 188  : 
; 189  :                         //Ahora hay que borrarlo de la lista de modelos:
; 190  :                         //Primero puenteamos a pFoundModelo:
; 191  :                         pPreviousModelo = pFoundModelo->m_pPrev;

	mov	rax, QWORD PTR pFoundModelo$[rbp]
	mov	rax, QWORD PTR [rax+1104]
	mov	QWORD PTR pPreviousModelo$[rbp], rax

; 192  :                         if (pPreviousModelo)

	cmp	QWORD PTR pPreviousModelo$[rbp], 0
	je	SHORT $LN8@delete

; 193  :                         {
; 194  :                             pPreviousModelo->m_pNext = pFoundModelo->m_pNext;

	mov	rax, QWORD PTR pPreviousModelo$[rbp]
	mov	rcx, QWORD PTR pFoundModelo$[rbp]
	mov	rcx, QWORD PTR [rcx+1096]
	mov	QWORD PTR [rax+1096], rcx

; 195  :                         }

	jmp	SHORT $LN9@delete
$LN8@delete:

; 196  :                         else
; 197  :                         {
; 198  :                             // Si no hay modelo anterior, ponemos de primero al siguiente 
; 199  :                             // del que vamos a borrar, es decir, shiftamos a la izquierda la lista
; 200  :                             // (que también puede ser NULL cuando no quede ningún modelo)
; 201  : 
; 202  :                             _pListaModelos = pFoundModelo->m_pNext;

	mov	rax, QWORD PTR pFoundModelo$[rbp]
	mov	rax, QWORD PTR [rax+1096]
	mov	QWORD PTR ?_pListaModelos@@3PEAXEA, rax	; _pListaModelos

; 203  :                             if (_pListaModelos)

	cmp	QWORD PTR ?_pListaModelos@@3PEAXEA, 0	; _pListaModelos
	je	SHORT $LN10@delete

; 204  :                             {
; 205  :                                 ((CModeloPtr)_pListaModelos)->m_pPrev = NULL; //El primero no tiene nunca un anterior

	mov	rax, QWORD PTR ?_pListaModelos@@3PEAXEA	; _pListaModelos
	mov	QWORD PTR [rax+1104], 0
$LN10@delete:
$LN9@delete:

; 206  :                             }
; 207  :                         }
; 208  :                         //Y luego liberamos pFoundModelo:
; 209  :                         free(pFoundModelo);

	mov	rcx, QWORD PTR pFoundModelo$[rbp]
	call	QWORD PTR __imp_free
$LN7@delete:
$LN5@delete:
$LN4@delete:
$LN3@delete:
$LN2@delete:

; 210  :                     }
; 211  :                 }
; 212  :             }
; 213  :         }
; 214  :     }
; 215  :     if (pObjeto->m_lpfnDefaultDoctorDestructor)

	mov	rax, QWORD PTR pObjeto$[rbp]
	cmp	QWORD PTR [rax+240], 0
	je	SHORT $LN11@delete

; 216  :     {
; 217  :         //Eliminar el modelo de CPersona de la cápsula heredada también
; 218  :         _delete(pObjeto->m_pPersona);

	mov	rax, QWORD PTR pObjeto$[rbp]
	mov	rcx, QWORD PTR [rax+8]
	call	?_delete@@YAXPEAUCPersona@@@Z		; _delete

; 219  : 
; 220  :         //Liberar objeto CDoctor
; 221  :         (pObjeto->m_lpfnDefaultDoctorDestructor)(pObjeto);

	mov	rcx, QWORD PTR pObjeto$[rbp]
	mov	rax, QWORD PTR pObjeto$[rbp]
	call	QWORD PTR [rax+240]

; 222  : 
; 223  :     }

	jmp	SHORT $LN12@delete
$LN11@delete:

; 224  :     else
; 225  :     {
; 226  :         free(pObjeto);

	mov	rcx, QWORD PTR pObjeto$[rbp]
	call	QWORD PTR __imp_free
$LN12@delete:

; 227  :     }
; 228  :     pObjeto = NULL;

	mov	QWORD PTR pObjeto$[rbp], 0

; 229  : }

	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:?_delete@@YAXPEAUCDoctor@@@Z$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+408]
	pop	rdi
	pop	rbp
	ret	0
?_delete@@YAXPEAUCDoctor@@@Z ENDP			; _delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Develop\Marcombo\MarSalud\MarSalud\Doctor.cpp
;	COMDAT ?_new@@YAPEAXPEAUCDoctor@@@Z
_TEXT	SEGMENT
pFoundModelo$ = 8
pNewModelo$ = 40
szTypeID$ = 80
bOK$ = 212
__$ArrayPad$ = 424
pInstancia$ = 464
?_new@@YAPEAXPEAUCDoctor@@@Z PROC			; _new, COMDAT

; 109  : {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 472				; 000001d8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 62					; 0000003eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+504]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__3E732C05_Doctor@cpp
	call	__CheckForDebuggerJustMyCode

; 110  :     CModeloPtr pFoundModelo = NULL;

	mov	QWORD PTR pFoundModelo$[rbp], 0

; 111  :     CModeloPtr pNewModelo = NULL;

	mov	QWORD PTR pNewModelo$[rbp], 0

; 112  :     char szTypeID[100];
; 113  :     bool bOK = false;

	mov	BYTE PTR bOK$[rbp], 0

; 114  : 
; 115  :     // Obtener el tipo del objeto:
; 116  :     memset(szTypeID, 0, sizeof(szTypeID));

	mov	r8d, 100				; 00000064H
	xor	edx, edx
	lea	rcx, QWORD PTR szTypeID$[rbp]
	call	memset

; 117  :     strcpy(szTypeID, typeid(*pInstancia).name());

	lea	rcx, OFFSET FLAT:??_R0?AUCDoctor@@@8
	call	?name@type_info@@QEBAPEBDXZ		; type_info::name
	mov	rdx, rax
	lea	rcx, QWORD PTR szTypeID$[rbp]
	call	strcpy

; 118  : 
; 119  :     if (pInstancia)

	cmp	QWORD PTR pInstancia$[rbp], 0
	je	$LN2@new

; 120  :     {
; 121  :         pInstancia->m_this = pInstancia; //Puntero de la instancia de doctor hacia sí misma

	mov	rax, QWORD PTR pInstancia$[rbp]
	mov	rcx, QWORD PTR pInstancia$[rbp]
	mov	QWORD PTR [rax], rcx

; 122  :         pFoundModelo = BuscarModelo((CModeloPtr)_pListaModelos, szTypeID); //Puntero de la instancia hacia el modelo

	lea	rdx, QWORD PTR szTypeID$[rbp]
	mov	rcx, QWORD PTR ?_pListaModelos@@3PEAXEA	; _pListaModelos
	call	?BuscarModelo@@YAPEAUCModelo@@PEAU1@PEAD@Z ; BuscarModelo
	mov	QWORD PTR pFoundModelo$[rbp], rax

; 123  :         if (pInstancia->m_pModelo)

	mov	rax, QWORD PTR pInstancia$[rbp]
	cmp	QWORD PTR [rax+16], 0
	je	SHORT $LN3@new

; 124  :         {
; 125  :             //Vincular instancia con modelo:
; 126  :             pInstancia->m_pModelo = pFoundModelo;

	mov	rax, QWORD PTR pInstancia$[rbp]
	mov	rcx, QWORD PTR pFoundModelo$[rbp]
	mov	QWORD PTR [rax+16], rcx

; 127  :             
; 128  :             //Datos de sistema propios del modelo:
; 129  :             strcpy(pInstancia->m_pModelo->m_szRuntimeClassName, szTypeID);

	mov	rax, QWORD PTR pInstancia$[rbp]
	mov	rax, QWORD PTR [rax+16]
	lea	rdx, QWORD PTR szTypeID$[rbp]
	mov	rcx, rax
	call	strcpy

; 130  : 
; 131  :             pInstancia->m_pModelo->m_nContador++; //Incrementar el contador de instancias de modelo

	mov	rax, QWORD PTR pInstancia$[rbp]
	mov	rax, QWORD PTR [rax+16]
	mov	eax, DWORD PTR [rax+100]
	inc	eax
	mov	rcx, QWORD PTR pInstancia$[rbp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	DWORD PTR [rcx+100], eax

; 132  : 
; 133  :             //Punteros propios personalizados para el tipo:
; 134  :             pInstancia->m_lpfnDefaultDoctorConstructor = DoctorDefaultConstructor;

	mov	rax, QWORD PTR pInstancia$[rbp]
	lea	rcx, OFFSET FLAT:?DoctorDefaultConstructor@@YAPEAUCDoctor@@XZ ; DoctorDefaultConstructor
	mov	QWORD PTR [rax+232], rcx

; 135  :             pInstancia->m_lpfnDefaultDoctorDestructor = DoctorDestructor;

	mov	rax, QWORD PTR pInstancia$[rbp]
	lea	rcx, OFFSET FLAT:?DoctorDestructor@@YAXPEAUCDoctor@@@Z ; DoctorDestructor
	mov	QWORD PTR [rax+240], rcx

; 136  :             pInstancia->m_lpfnImprimirFicha;
; 137  :         }

	jmp	SHORT $LN4@new
$LN3@new:

; 138  :         else
; 139  :         {
; 140  :             //Crear dinámicamente el modelo:
; 141  :             pNewModelo = (CModeloPtr)malloc(sizeof(CModelo));

	mov	ecx, 1112				; 00000458H
	call	QWORD PTR __imp_malloc
	mov	QWORD PTR pNewModelo$[rbp], rax

; 142  : 
; 143  :             //Poner a cero el modelo:
; 144  :             memset(pNewModelo, 0, sizeof(CModelo));

	mov	r8d, 1112				; 00000458H
	xor	edx, edx
	mov	rcx, QWORD PTR pNewModelo$[rbp]
	call	memset

; 145  :             memcpy(&pNewModelo->m_persona, pInstancia, sizeof(CDoctor));

	mov	rax, QWORD PTR pNewModelo$[rbp]
	add	rax, 104				; 00000068H
	mov	r8d, 256				; 00000100H
	mov	rdx, QWORD PTR pInstancia$[rbp]
	mov	rcx, rax
	call	memcpy

; 146  : 
; 147  :             //Vincular la instancia con el modelo:
; 148  :             pInstancia->m_pModelo = pNewModelo;

	mov	rax, QWORD PTR pInstancia$[rbp]
	mov	rcx, QWORD PTR pNewModelo$[rbp]
	mov	QWORD PTR [rax+16], rcx

; 149  : 
; 150  :             //Copiar el nombre del modelo a partir del typeid
; 151  :             strcpy(pNewModelo->m_szRuntimeClassName, szTypeID);

	mov	rax, QWORD PTR pNewModelo$[rbp]
	lea	rdx, QWORD PTR szTypeID$[rbp]
	mov	rcx, rax
	call	strcpy

; 152  : 
; 153  :             //Inicializar el contador de instancias de este modelo a 1
; 154  :             pNewModelo->m_nContador = 1;

	mov	rax, QWORD PTR pNewModelo$[rbp]
	mov	DWORD PTR [rax+100], 1

; 155  : 
; 156  :             bOK = InsertarModelo((CModeloPtr)_pListaModelos, pNewModelo);

	mov	rdx, QWORD PTR pNewModelo$[rbp]
	mov	rcx, QWORD PTR ?_pListaModelos@@3PEAXEA	; _pListaModelos
	call	?InsertarModelo@@YA_NPEAUCModelo@@0@Z	; InsertarModelo
	mov	BYTE PTR bOK$[rbp], al
$LN4@new:
$LN2@new:

; 157  :         }
; 158  :     }
; 159  :     return pInstancia;

	mov	rax, QWORD PTR pInstancia$[rbp]

; 160  : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:?_new@@YAPEAXPEAUCDoctor@@@Z$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+440]
	pop	rdi
	pop	rbp
	ret	0
?_new@@YAPEAXPEAUCDoctor@@@Z ENDP			; _new
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Develop\Marcombo\MarSalud\MarSalud\Doctor.cpp
;	COMDAT ?DoctorDestructor@@YAXPEAUCDoctor@@@Z
_TEXT	SEGMENT
pObjeto$ = 224
?DoctorDestructor@@YAXPEAUCDoctor@@@Z PROC		; DoctorDestructor, COMDAT

; 90   : {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__3E732C05_Doctor@cpp
	call	__CheckForDebuggerJustMyCode

; 91   :     // Otras tareas de liberación y restauración
; 92   :     // de recursos...
; 93   : 
; 94   :     //Destruir el propio objeto
; 95   :     if (pObjeto)

	cmp	QWORD PTR pObjeto$[rbp], 0
	je	SHORT $LN2@DoctorDest

; 96   :     {
; 97   :         if (pObjeto->m_pPersona)

	mov	rax, QWORD PTR pObjeto$[rbp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@DoctorDest

; 98   :         {
; 99   :             // El _delete de Doctor ya ha llamado al destructor 
; 100  :             // de CPersona heredada, no hace falta llamarlo dos veces
; 101  :             pObjeto->m_pPersona = NULL;

	mov	rax, QWORD PTR pObjeto$[rbp]
	mov	QWORD PTR [rax+8], 0
$LN3@DoctorDest:

; 102  :         }
; 103  :         free(pObjeto);

	mov	rcx, QWORD PTR pObjeto$[rbp]
	call	QWORD PTR __imp_free

; 104  :         pObjeto = NULL;

	mov	QWORD PTR pObjeto$[rbp], 0
$LN2@DoctorDest:

; 105  :     }
; 106  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?DoctorDestructor@@YAXPEAUCDoctor@@@Z ENDP		; DoctorDestructor
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Develop\Marcombo\MarSalud\MarSalud\Doctor.cpp
;	COMDAT ?DoctorConstructorCopia@@YAPEAUCDoctor@@PEAUCPersona@@@Z
_TEXT	SEGMENT
pNuevaInstancia$ = 8
pPersonaOriginal$ = 256
?DoctorConstructorCopia@@YAPEAUCDoctor@@PEAUCPersona@@@Z PROC ; DoctorConstructorCopia, COMDAT

; 70   : {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__3E732C05_Doctor@cpp
	call	__CheckForDebuggerJustMyCode

; 71   :     CDoctorPtr pNuevaInstancia = NULL;

	mov	QWORD PTR pNuevaInstancia$[rbp], 0

; 72   : 
; 73   :     //Llamar al constructor por defecto:
; 74   :     pNuevaInstancia = DoctorDefaultConstructor();

	call	?DoctorDefaultConstructor@@YAPEAUCDoctor@@XZ ; DoctorDefaultConstructor
	mov	QWORD PTR pNuevaInstancia$[rbp], rax

; 75   :     if (pNuevaInstancia)

	cmp	QWORD PTR pNuevaInstancia$[rbp], 0
	je	SHORT $LN2@DoctorCons

; 76   :     {
; 77   :         //Cargar valores todos los campos de golpe en una sola operación:
; 78   :         memcpy(pNuevaInstancia->m_pPersona, pPersonaOriginal, sizeof(CPersona));

	mov	r8d, 992				; 000003e0H
	mov	rdx, QWORD PTR pPersonaOriginal$[rbp]
	mov	rax, QWORD PTR pNuevaInstancia$[rbp]
	mov	rcx, QWORD PTR [rax+8]
	call	memcpy

; 79   : 
; 80   :         // Corregimos tras em memcpy para que el m_this de la persona original 
; 81   :         // no nos machaque el m_this de la persona duplicada dentro de CDoctor:
; 82   :         pNuevaInstancia->m_pPersona->m_this = pNuevaInstancia->m_pPersona;

	mov	rax, QWORD PTR pNuevaInstancia$[rbp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR pNuevaInstancia$[rbp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax], rcx
$LN2@DoctorCons:

; 83   :     }
; 84   :     //La vinculación con el modelo se hace desde el new
; 85   : 
; 86   :     return pNuevaInstancia;

	mov	rax, QWORD PTR pNuevaInstancia$[rbp]

; 87   : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
?DoctorConstructorCopia@@YAPEAUCDoctor@@PEAUCPersona@@@Z ENDP ; DoctorConstructorCopia
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Develop\Marcombo\MarSalud\MarSalud\Doctor.cpp
;	COMDAT ?DoctorConstructor@@YAPEAUCDoctor@@HPEAD000@Z
_TEXT	SEGMENT
pNuevaInstancia$ = 8
nNumColegiado$ = 256
lpszNIF$ = 264
lpszNombre$ = 272
lpszApellidos$ = 280
lpszEspecialidad$ = 288
?DoctorConstructor@@YAPEAUCDoctor@@HPEAD000@Z PROC	; DoctorConstructor, COMDAT

; 49   : {

$LN4:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__3E732C05_Doctor@cpp
	call	__CheckForDebuggerJustMyCode

; 50   :     CDoctorPtr pNuevaInstancia = NULL;

	mov	QWORD PTR pNuevaInstancia$[rbp], 0

; 51   : 
; 52   :     //Llamar al constructor por defecto:
; 53   :     pNuevaInstancia = DoctorDefaultConstructor();

	call	?DoctorDefaultConstructor@@YAPEAUCDoctor@@XZ ; DoctorDefaultConstructor
	mov	QWORD PTR pNuevaInstancia$[rbp], rax

; 54   :     if (pNuevaInstancia)

	cmp	QWORD PTR pNuevaInstancia$[rbp], 0
	je	SHORT $LN2@DoctorCons

; 55   :     {
; 56   :         //Valores que van a la estructura principal:
; 57   :         pNuevaInstancia->m_nNumColegiado, nNumColegiado;
; 58   :         strcpy(pNuevaInstancia->m_szEspecialidad, lpszEspecialidad);

	mov	rax, QWORD PTR pNuevaInstancia$[rbp]
	add	rax, 128				; 00000080H
	mov	rdx, QWORD PTR lpszEspecialidad$[rbp]
	mov	rcx, rax
	call	strcpy

; 59   : 
; 60   :         //Valores que van a la estructura heredada CPersona:
; 61   :         strcpy(pNuevaInstancia->m_pPersona->m_szNIF, lpszNIF);

	mov	rax, QWORD PTR pNuevaInstancia$[rbp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 96					; 00000060H
	mov	rdx, QWORD PTR lpszNIF$[rbp]
	mov	rcx, rax
	call	strcpy

; 62   :         strcpy(pNuevaInstancia->m_pPersona->m_szNombre, lpszNombre);

	mov	rax, QWORD PTR pNuevaInstancia$[rbp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 196				; 000000c4H
	mov	rdx, QWORD PTR lpszNombre$[rbp]
	mov	rcx, rax
	call	strcpy

; 63   :         strcpy(pNuevaInstancia->m_pPersona->m_szApellidos, lpszApellidos);

	mov	rax, QWORD PTR pNuevaInstancia$[rbp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 256				; 00000100H
	mov	rdx, QWORD PTR lpszApellidos$[rbp]
	mov	rcx, rax
	call	strcpy
$LN2@DoctorCons:

; 64   :     }
; 65   :     //La vinculación con el modelo se hace desde el new
; 66   :     return pNuevaInstancia;

	mov	rax, QWORD PTR pNuevaInstancia$[rbp]

; 67   : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
?DoctorConstructor@@YAPEAUCDoctor@@HPEAD000@Z ENDP	; DoctorConstructor
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Develop\Marcombo\MarSalud\MarSalud\Doctor.cpp
;	COMDAT ?DoctorDefaultConstructor@@YAPEAUCDoctor@@XZ
_TEXT	SEGMENT
pNuevaInstancia$ = 8
pNewModelo$ = 40
pFoundModelo$ = 72
pLastModelo$ = 104
szTypeID$ = 144
__$ArrayPad$ = 456
?DoctorDefaultConstructor@@YAPEAUCDoctor@@XZ PROC	; DoctorDefaultConstructor, COMDAT

; 7    : {

$LN4:
	push	rbp
	push	rdi
	sub	rsp, 504				; 000001f8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 70					; 00000046H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__3E732C05_Doctor@cpp
	call	__CheckForDebuggerJustMyCode

; 8    :     CDoctorPtr pNuevaInstancia;
; 9    :     CModelo* pNewModelo = NULL;

	mov	QWORD PTR pNewModelo$[rbp], 0

; 10   :     CModelo* pFoundModelo = NULL;

	mov	QWORD PTR pFoundModelo$[rbp], 0

; 11   :     CModelo* pLastModelo = NULL;

	mov	QWORD PTR pLastModelo$[rbp], 0

; 12   :     char szTypeID[100];
; 13   : 
; 14   :     // Dar de alta la instancia:
; 15   :     pNuevaInstancia = (CDoctorPtr)malloc(sizeof(CDoctor));

	mov	ecx, 256				; 00000100H
	call	QWORD PTR __imp_malloc
	mov	QWORD PTR pNuevaInstancia$[rbp], rax

; 16   :     if (pNuevaInstancia)

	cmp	QWORD PTR pNuevaInstancia$[rbp], 0
	je	$LN2@DoctorDefa

; 17   :     {
; 18   :         // Poner a cero todo el objeto:
; 19   :         memset(pNuevaInstancia, 0, sizeof(CDoctor));

	mov	r8d, 256				; 00000100H
	xor	edx, edx
	mov	rcx, QWORD PTR pNuevaInstancia$[rbp]
	call	memset

; 20   : 
; 21   :         //Apuntarse a sí mismo:
; 22   :         pNuevaInstancia->m_this = pNuevaInstancia;

	mov	rax, QWORD PTR pNuevaInstancia$[rbp]
	mov	rcx, QWORD PTR pNuevaInstancia$[rbp]
	mov	QWORD PTR [rax], rcx

; 23   : 
; 24   :         //Cargar punteros a funciones propias de CDoctor:
; 25   :         pNuevaInstancia->m_lpfnDefaultDoctorConstructor = DoctorDefaultConstructor;

	mov	rax, QWORD PTR pNuevaInstancia$[rbp]
	lea	rcx, OFFSET FLAT:?DoctorDefaultConstructor@@YAPEAUCDoctor@@XZ ; DoctorDefaultConstructor
	mov	QWORD PTR [rax+232], rcx

; 26   :         pNuevaInstancia->m_lpfnDefaultDoctorDestructor = DoctorDestructor;

	mov	rax, QWORD PTR pNuevaInstancia$[rbp]
	lea	rcx, OFFSET FLAT:?DoctorDestructor@@YAXPEAUCDoctor@@@Z ; DoctorDestructor
	mov	QWORD PTR [rax+240], rcx

; 27   :         pNuevaInstancia->m_lpfnImprimirFicha = DoctorImprimirFicha;

	mov	rax, QWORD PTR pNuevaInstancia$[rbp]
	lea	rcx, OFFSET FLAT:?DoctorImprimirFicha@@YAXPEAUCDoctor@@H@Z ; DoctorImprimirFicha
	mov	QWORD PTR [rax+248], rcx

; 28   : 
; 29   :         //Crear la cápsula del objeto padre del cual hereda:
; 30   :         pNuevaInstancia->m_pPersona = (CPersonaPtr)_new(PersonaDefaultConstructor());

	call	?PersonaDefaultConstructor@@YAPEAUCPersona@@XZ ; PersonaDefaultConstructor
	mov	rcx, rax
	call	?_new@@YAPEAXPEAUCPersona@@@Z		; _new
	mov	rcx, QWORD PTR pNuevaInstancia$[rbp]
	mov	QWORD PTR [rcx+8], rax

; 31   : 
; 32   :         //Sólo a efectos didácticos de comprobación:
; 33   :         //Obtener el tipo de objeto de la cápsula:
; 34   :         memset(szTypeID, 0, sizeof(szTypeID));

	mov	r8d, 100				; 00000064H
	xor	edx, edx
	lea	rcx, QWORD PTR szTypeID$[rbp]
	call	memset

; 35   :         strcpy(szTypeID, typeid(*pNuevaInstancia->m_pPersona).name());

	lea	rcx, OFFSET FLAT:??_R0?AUCPersona@@@8
	call	?name@type_info@@QEBAPEBDXZ		; type_info::name
	mov	rdx, rax
	lea	rcx, QWORD PTR szTypeID$[rbp]
	call	strcpy

; 36   : 
; 37   :         // Obtener el tipo del objeto doctor:
; 38   :         memset(szTypeID, 0, sizeof(szTypeID));

	mov	r8d, 100				; 00000064H
	xor	edx, edx
	lea	rcx, QWORD PTR szTypeID$[rbp]
	call	memset

; 39   :         strcpy(szTypeID, typeid(*pNuevaInstancia).name());

	lea	rcx, OFFSET FLAT:??_R0?AUCDoctor@@@8
	call	?name@type_info@@QEBAPEBDXZ		; type_info::name
	mov	rdx, rax
	lea	rcx, QWORD PTR szTypeID$[rbp]
	call	strcpy
$LN2@DoctorDefa:

; 40   :     }
; 41   :     //La vinculación con el modelo se hace desde el new
; 42   :     return pNuevaInstancia;

	mov	rax, QWORD PTR pNuevaInstancia$[rbp]

; 43   : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:?DoctorDefaultConstructor@@YAPEAUCDoctor@@XZ$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+472]
	pop	rdi
	pop	rbp
	ret	0
?DoctorDefaultConstructor@@YAPEAUCDoctor@@XZ ENDP	; DoctorDefaultConstructor
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vcruntime_typeinfo.h
;	COMDAT ?name@type_info@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 224
?name@type_info@@QEBAPEBDXZ PROC			; type_info::name, COMDAT

; 114  :     {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__0632977E_vcruntime_typeinfo@h
	call	__CheckForDebuggerJustMyCode

; 115  :         #ifdef _M_CEE_PURE
; 116  :         return __std_type_info_name(&_Data, static_cast<__type_info_node*>(__type_info_root_node.ToPointer()));
; 117  :         #else
; 118  :         return __std_type_info_name(&_Data, &__type_info_root_node);

	mov	rax, QWORD PTR this$[rbp]
	add	rax, 8
	lea	rdx, OFFSET FLAT:?__type_info_root_node@@3U__type_info_node@@A ; __type_info_root_node
	mov	rcx, rax
	call	__std_type_info_name

; 119  :         #endif
; 120  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?name@type_info@@QEBAPEBDXZ ENDP			; type_info::name
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Result$ = 4
_ArgList$ = 40
__$ArrayPad$ = 280
_Format$ = 320
printf	PROC						; COMDAT

; 956  :     {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rbp
	push	rdi
	sub	rsp, 328				; 00000148H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 26
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+360]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__C1EC35D3_stdio@h
	call	__CheckForDebuggerJustMyCode

; 957  :         int _Result;
; 958  :         va_list _ArgList;
; 959  :         __crt_va_start(_ArgList, _Format);

	lea	rax, QWORD PTR _Format$[rbp+8]
	mov	QWORD PTR _ArgList$[rbp], rax

; 960  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	mov	ecx, 1
	call	QWORD PTR __imp___acrt_iob_func
	mov	r9, QWORD PTR _ArgList$[rbp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR _Format$[rbp]
	mov	rcx, rax
	call	_vfprintf_l
	mov	DWORD PTR _Result$[rbp], eax

; 961  :         __crt_va_end(_ArgList);

	mov	QWORD PTR _ArgList$[rbp], 0

; 962  :         return _Result;

	mov	eax, DWORD PTR _Result$[rbp]

; 963  :     }

	mov	edi, eax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:printf$rtcFrameData
	call	_RTC_CheckStackVars
	mov	eax, edi
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+296]
	pop	rdi
	pop	rbp
	ret	0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 224
_Format$ = 232
_Locale$ = 240
_ArgList$ = 248
_vfprintf_l PROC					; COMDAT

; 644  :     {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+48]
	lea	rcx, OFFSET FLAT:__C1EC35D3_stdio@h
	call	__CheckForDebuggerJustMyCode

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	mov	rcx, QWORD PTR _ArgList$[rbp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Locale$[rbp]
	mov	r8, QWORD PTR _Format$[rbp]
	mov	rdx, QWORD PTR _Stream$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	QWORD PTR __imp___stdio_common_vfprintf

; 646  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 90   :     {

$LN3:
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__44420885_corecrt_stdio_config@h
	call	__CheckForDebuggerJustMyCode

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Develop\Marcombo\MarSalud\MarSalud\Doctor.cpp
;	COMDAT ?__empty_global_delete@@YAXPEAX_K@Z
_TEXT	SEGMENT
__formal$ = 224
__formal$ = 232
?__empty_global_delete@@YAXPEAX_K@Z PROC		; __empty_global_delete, COMDAT

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__3E732C05_Doctor@cpp
	call	__CheckForDebuggerJustMyCode
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?__empty_global_delete@@YAXPEAX_K@Z ENDP		; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Develop\Marcombo\MarSalud\MarSalud\Doctor.cpp
;	COMDAT ?__empty_global_delete@@YAXPEAX@Z
_TEXT	SEGMENT
__formal$ = 224
?__empty_global_delete@@YAXPEAX@Z PROC			; __empty_global_delete, COMDAT

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__3E732C05_Doctor@cpp
	call	__CheckForDebuggerJustMyCode
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?__empty_global_delete@@YAXPEAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
